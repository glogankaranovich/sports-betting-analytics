"""
User Models - Data models and DynamoDB operations for user-defined betting models
"""
import os
import uuid
from datetime import datetime
from decimal import Decimal
from typing import Any, Dict, List, Optional

import boto3
from boto3.dynamodb.conditions import Key

dynamodb = boto3.resource("dynamodb", region_name="us-east-1")
USER_MODELS_TABLE = os.environ.get("USER_MODELS_TABLE", "Dev-UserModels-UserModels")
MODEL_PREDICTIONS_TABLE = os.environ.get(
    "MODEL_PREDICTIONS_TABLE", "Dev-UserModels-ModelPredictions"
)

user_models_table = dynamodb.Table(USER_MODELS_TABLE)
model_predictions_table = dynamodb.Table(MODEL_PREDICTIONS_TABLE)


def convert_floats_to_decimal(obj: Any) -> Any:
    """Recursively convert floats to Decimal for DynamoDB"""
    if isinstance(obj, float):
        return Decimal(str(obj))
    elif isinstance(obj, dict):
        return {k: convert_floats_to_decimal(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [convert_floats_to_decimal(item) for item in obj]
    return obj


class UserModel:
    """User-defined betting model"""

    def __init__(
        self,
        user_id: str,
        name: str,
        description: str,
        sport: str,
        bet_types: List[str],
        data_sources: Dict,
        min_confidence: float,
        model_id: Optional[str] = None,
        custom_datasets: Optional[List[Dict]] = None,
        status: str = "active",
        created_at: Optional[str] = None,
        updated_at: Optional[str] = None,
    ):
        self.model_id = model_id or f"model_{uuid.uuid4().hex[:12]}"
        self.user_id = user_id
        self.name = name
        self.description = description
        self.sport = sport
        self.bet_types = bet_types
        self.data_sources = data_sources
        self.custom_datasets = custom_datasets or []
        self.min_confidence = min_confidence
        self.status = status
        self.created_at = created_at or datetime.utcnow().isoformat()
        self.updated_at = updated_at or datetime.utcnow().isoformat()

    def to_dynamodb(self) -> Dict:
        """Convert to DynamoDB item"""
        return {
            "PK": f"USER#{self.user_id}",
            "SK": f"MODEL#{self.model_id}",
            "GSI1PK": f"USER#{self.user_id}",
            "GSI1SK": f"CREATED#{self.created_at}",
            "model_id": self.model_id,
            "user_id": self.user_id,
            "name": self.name,
            "description": self.description,
            "sport": self.sport,
            "bet_types": self.bet_types,
            "data_sources": convert_floats_to_decimal(self.data_sources),
            "custom_datasets": convert_floats_to_decimal(self.custom_datasets),
            "min_confidence": Decimal(str(self.min_confidence)),
            "status": self.status,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }

    @classmethod
    def from_dynamodb(cls, item: Dict) -> "UserModel":
        """Create from DynamoDB item"""
        return cls(
            model_id=item["model_id"],
            user_id=item["user_id"],
            name=item["name"],
            description=item["description"],
            sport=item["sport"],
            bet_types=item["bet_types"],
            data_sources=item["data_sources"],
            custom_datasets=item.get("custom_datasets", []),
            min_confidence=float(item["min_confidence"]),
            status=item.get("status", "active"),
            created_at=item["created_at"],
            updated_at=item["updated_at"],
        )

    def save(self):
        """Save model to DynamoDB"""
        self.updated_at = datetime.utcnow().isoformat()
        user_models_table.put_item(Item=self.to_dynamodb())

    @staticmethod
    def get(user_id: str, model_id: str) -> Optional["UserModel"]:
        """Get model by ID"""
        response = user_models_table.get_item(
            Key={"PK": f"USER#{user_id}", "SK": f"MODEL#{model_id}"}
        )
        item = response.get("Item")
        return UserModel.from_dynamodb(item) if item else None

    @staticmethod
    def list_by_user(user_id: str, limit: int = 50) -> List["UserModel"]:
        """List all models for a user"""
        response = user_models_table.query(
            IndexName="UserModelsIndex",
            KeyConditionExpression=Key("GSI1PK").eq(f"USER#{user_id}"),
            ScanIndexForward=False,  # Most recent first
            Limit=limit,
        )
        return [UserModel.from_dynamodb(item) for item in response.get("Items", [])]

    def delete(self):
        """Delete model"""
        user_models_table.delete_item(
            Key={"PK": f"USER#{self.user_id}", "SK": f"MODEL#{self.model_id}"}
        )


class ModelPrediction:
    """Prediction generated by a user model"""

    def __init__(
        self,
        model_id: str,
        user_id: str,
        game_id: str,
        sport: str,
        prediction: str,
        confidence: float,
        reasoning: str,
        bet_type: str,
        home_team: str,
        away_team: str,
        commence_time: str,
        outcome: str = "pending",
        created_at: Optional[str] = None,
    ):
        self.model_id = model_id
        self.user_id = user_id
        self.game_id = game_id
        self.sport = sport
        self.prediction = prediction
        self.confidence = confidence
        self.reasoning = reasoning
        self.bet_type = bet_type
        self.home_team = home_team
        self.away_team = away_team
        self.commence_time = commence_time
        self.outcome = outcome
        self.created_at = created_at or datetime.utcnow().isoformat()

    def to_dynamodb(self) -> Dict:
        """Convert to DynamoDB item"""
        return {
            "PK": f"MODEL#{self.model_id}",
            "SK": f"GAME#{self.game_id}#{self.created_at}",
            "GSI1PK": f"MODEL#{self.model_id}",
            "GSI1SK": f"OUTCOME#{self.outcome}#{self.created_at}",
            "model_id": self.model_id,
            "user_id": self.user_id,
            "game_id": self.game_id,
            "sport": self.sport,
            "prediction": self.prediction,
            "confidence": Decimal(str(self.confidence)),
            "reasoning": self.reasoning,
            "bet_type": self.bet_type,
            "home_team": self.home_team,
            "away_team": self.away_team,
            "commence_time": self.commence_time,
            "outcome": self.outcome,
            "created_at": self.created_at,
        }

    @classmethod
    def from_dynamodb(cls, item: Dict) -> "ModelPrediction":
        """Create from DynamoDB item"""
        return cls(
            model_id=item["model_id"],
            user_id=item["user_id"],
            game_id=item["game_id"],
            sport=item["sport"],
            prediction=item["prediction"],
            confidence=float(item["confidence"]),
            reasoning=item["reasoning"],
            bet_type=item["bet_type"],
            home_team=item["home_team"],
            away_team=item["away_team"],
            commence_time=item["commence_time"],
            outcome=item.get("outcome", "pending"),
            created_at=item["created_at"],
        )

    def save(self):
        """Save prediction to DynamoDB"""
        model_predictions_table.put_item(Item=self.to_dynamodb())

    @staticmethod
    def list_by_model(model_id: str, limit: int = 100) -> List["ModelPrediction"]:
        """List predictions for a model"""
        response = model_predictions_table.query(
            KeyConditionExpression=Key("PK").eq(f"MODEL#{model_id}"),
            ScanIndexForward=False,  # Most recent first
            Limit=limit,
        )
        return [
            ModelPrediction.from_dynamodb(item) for item in response.get("Items", [])
        ]

    @staticmethod
    def get_performance(model_id: str) -> Dict:
        """Get performance metrics for a model"""
        # Query all predictions
        response = model_predictions_table.query(
            IndexName="ModelPerformanceIndex",
            KeyConditionExpression=Key("GSI1PK").eq(f"MODEL#{model_id}"),
        )

        predictions = [
            ModelPrediction.from_dynamodb(item) for item in response.get("Items", [])
        ]

        total = len(predictions)
        correct = sum(1 for p in predictions if p.outcome == "correct")
        incorrect = sum(1 for p in predictions if p.outcome == "incorrect")
        pending = sum(1 for p in predictions if p.outcome == "pending")

        accuracy = (correct / (correct + incorrect)) if (correct + incorrect) > 0 else 0
        avg_confidence = (
            sum(p.confidence for p in predictions) / total if total > 0 else 0
        )

        return {
            "total_predictions": total,
            "correct": correct,
            "incorrect": incorrect,
            "pending": pending,
            "accuracy": accuracy,
            "avg_confidence": avg_confidence,
        }


def validate_model_config(config: Dict) -> tuple[bool, Optional[str]]:
    """Validate model configuration"""

    # Check required fields
    required = [
        "name",
        "description",
        "sport",
        "bet_types",
        "data_sources",
        "min_confidence",
    ]
    for field in required:
        if field not in config:
            return False, f"Missing required field: {field}"

    # Validate name length
    if not (3 <= len(config["name"]) <= 50):
        return False, "Name must be 3-50 characters"

    # Validate description length
    if not (10 <= len(config["description"]) <= 200):
        return False, "Description must be 10-200 characters"

    # Validate sport
    valid_sports = [
        "basketball_nba",
        "americanfootball_nfl",
        "baseball_mlb",
        "icehockey_nhl",
    ]
    if config["sport"] not in valid_sports:
        return False, f"Invalid sport. Must be one of: {valid_sports}"

    # Validate bet types
    valid_bet_types = ["h2h", "spreads", "totals"]
    if not config["bet_types"] or not all(
        bt in valid_bet_types for bt in config["bet_types"]
    ):
        return False, f"Invalid bet types. Must be one or more of: {valid_bet_types}"

    # Validate data sources
    data_sources = config["data_sources"]
    if not data_sources:
        return False, "At least one data source must be enabled"

    enabled_sources = [s for s, cfg in data_sources.items() if cfg.get("enabled")]
    if not enabled_sources:
        return False, "At least one data source must be enabled"

    # Validate weights sum to ~100%
    total_weight = sum(
        cfg.get("weight", 0) for cfg in data_sources.values() if cfg.get("enabled")
    )
    if not (0.99 <= total_weight <= 1.01):  # Allow 1% tolerance
        return False, f"Weights must sum to 100% (currently {total_weight * 100:.1f}%)"

    # Validate min confidence
    if not (0.5 <= config["min_confidence"] <= 0.95):
        return False, "Min confidence must be between 50% and 95%"

    return True, None
